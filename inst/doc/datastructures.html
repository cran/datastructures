<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Introduction</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>

<!-- MathJax scripts -->
<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h2>Introduction</h2>

<p><code>datastructures</code> implements various data structures that are frequently used in computer science. Among these are for example <em>Fibonacci heaps</em>, <em>stacks</em>, <em>queues</em> or <em>hashmaps</em>. Advanced data structures are essential
in many computer science and statistics problems, for example graph algorithms or string analysis. The package uses <code>Boost</code> and <code>STL</code> data types and extends these to <code>R</code> with <code>Rcpp</code> modules.</p>

<h2>Fibonacci and binomial heaps</h2>

<p>Fibonacci and binomial heaps are priority queue data structures using the minimum heap property. They can be represented using collections of trees or linked lists consisting of <em>nodes</em> of elements. Every node is a pair of keys and values, where the key decides the priority of the <em>node</em> in the heap. Fibonacci heaps have various applications, one of the most famous being in efficiently finding shortest paths using Dijkstra&#39;s algorithm. Fibonacci heaps can add values in amortized \(\mathcal{O}(1)\) time and remove the minimum value in \(\mathcal{O}(log \, n)\) time making them a good choice in many real world scenarios. Binomial heaps have in general slightly worse asymptotic bounds. However, removing the minimum element (<code>pop</code>) has an asymptotically tight bound of \(\Theta(log \, n)\). The two classes have the exact same methods, so every method explained here is available for the other class, too.</p>

<p>You can create a heap like this:</p>

<pre><code class="r">  fheap &lt;- fibonacci_heap(&quot;numeric&quot;)
  bheap &lt;- binomial_heap(&quot;numeric&quot;)
</code></pre>

<p>This gives us heaps with <code>numeric</code> keys. You can pick from either <code>integer</code>, <code>numeric</code> or <code>character</code> keys.</p>

<h3>Inserting nodes</h3>

<p>The values an be arbitray, meaning, that you can add <code>data.frames</code>, <code>vectors</code> or any object you like.
So if we insert several key-value pairs, the pair with the <em>minimum</em> key would have the highest <em>priority</em>.
Let&#39;s insert some values and have a look:</p>

<pre><code class="r">  keys   &lt;- sample(seq(0, 1, by=.2))
  values &lt;- paste0(&quot;V&quot;, keys)
  fheap  &lt;- insert(fheap, keys, values)

  size(fheap)
</code></pre>

<pre><code>## [1] 6
</code></pre>

<p>There are also some other ways to insert into a heap. If you want to insert a <code>vector</code>ial value, do this:</p>

<pre><code class="r">  fheap  &lt;- insert(fheap, -1, letters[1:5])
  peek(fheap)
</code></pre>

<pre><code>## $`-1`
## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot;
</code></pre>

<p>As described above, you can basically add any tope to your heap.
Here I add two ke-value pairs. The keys are provided as vectors, while the values
are a list of different objects.</p>

<pre><code class="r">  fheap  &lt;- insert(fheap, -2, list(a=5))
  fheap  &lt;- insert(fheap, -3, data.frame(A=rnorm(5), B=1:5))

  peek(fheap)
</code></pre>

<pre><code>## $`-3`
##             A B
## 1  0.12490994 1
## 2 -0.08443145 2
## 3 -1.72988336 3
## 4  0.05831478 4
## 5  0.95520275 5
</code></pre>

<p><strong>NOTE</strong>: for efficienty it is recommended to insert all values at the same time, 
if you can do this. This should be way faster.
If we insert multiple objects, we need to wrap it around a list.</p>

<pre><code class="r">  fheap  &lt;- insert(fheap, c(-4, -5, -6), list(list(a=2), letters[1:4], &quot;hallo&quot;))
</code></pre>

<h3>Peek and pop</h3>

<p>Since Fibonacci and binomial heaps use the minimum heap property the first
element in the heap should be <code>-6 -&gt; &quot;hello</code>, because -6 has the lowest value.</p>

<pre><code class="r">  peek(fheap)
</code></pre>

<pre><code>## $`-6`
## [1] &quot;hallo&quot;
</code></pre>

<pre><code class="r">  size(fheap)
</code></pre>

<pre><code>## [1] 12
</code></pre>

<p>That worked nicely. <code>peek</code> gives us the first element from the heap <em>without removing it</em>.
If we want to have it removed we call the <code>pop</code> function. Of course this changes the priority of the heap:</p>

<pre><code class="r">  pop(fheap)
</code></pre>

<pre><code>## $`-6`
## [1] &quot;hallo&quot;
</code></pre>

<pre><code class="r">  size(fheap)
</code></pre>

<pre><code>## [1] 11
</code></pre>

<p>You can alternatively insert values like this:</p>

<pre><code class="r">  fheap[-10] &lt;- &quot;V-1&quot;
  peek(fheap)
</code></pre>

<pre><code>## $`-10`
## [1] &quot;V-1&quot;
</code></pre>

<p>This works for all the described <code>insert</code> methods above. </p>

<h3>Decreasing the key of a node</h3>

<p>Sometimes, we want to decrease a key and rearrange its position in the
heap. If we have a <em>unique</em> key this can be easily done:</p>

<pre><code class="r">  decrease_key(fheap, from=-10, to=-11)
</code></pre>

<pre><code>## An object of class fibonacci_heap&lt;numeric, SEXP&gt;
## 
## Peek: -11 -&gt; character, ...
</code></pre>

<pre><code class="r">  peek(fheap)
</code></pre>

<pre><code>## $`-11`
## [1] &quot;V-1&quot;
</code></pre>

<p>The function takes vectors, so you can also pass vectorial <code>to</code> and <code>from</code> arguments:</p>

<pre><code class="r">  decrease_key(fheap, from=c(-4, -5), to=c(-15, -13))
</code></pre>

<pre><code>## An object of class fibonacci_heap&lt;numeric, SEXP&gt;
## 
## Peek: -15 -&gt; list, ...
</code></pre>

<pre><code class="r">  peek(fheap)
</code></pre>

<pre><code>## $`-15`
## $`-15`$a
## [1] 2
</code></pre>

<h3>Getting node ids</h3>

<p>However, things get more complicated if we have multiple identical keys and want 
to decrease a specific one. In this case, in order to decrease to correct node,
we need to get its <code>handle</code> first:</p>

<pre><code class="r">  handle(fheap, -15)
</code></pre>

<pre><code>## [[1]]
## [[1]]$handle
## [1] &quot;handle-9&quot;
## 
## [[1]]$value
## [[1]]$value$a
## [1] 2
</code></pre>

<p>The <code>handle</code> method returns the <code>id</code> of the node and the <code>value</code> that is stored
for a given <code>key</code> (in this case -15). Thus if we want to decrease a node with 
ambiguous key, we also need to specify the handle (e.g. the <code>id</code>):</p>

<pre><code class="r">  hand &lt;- handle(fheap, -15)  
  decrease_key(fheap, -15, -20, hand[[1]]$handle)
</code></pre>

<pre><code>## An object of class fibonacci_heap&lt;numeric, SEXP&gt;
## 
## Peek: -20 -&gt; list, ...
</code></pre>

<pre><code class="r">  peek(fheap)
</code></pre>

<pre><code>## $`-20`
## $`-20`$a
## [1] 2
</code></pre>

<p>The <code>handle</code> method always returns a list where every element represents a node in the heap. 
The <code>handle</code> function is vectorized, so you can supply are vector of keys and will receive the handles that fit thse:</p>

<pre><code class="r"> handle(fheap, c(-3))
</code></pre>

<pre><code>## [[1]]
## [[1]]$handle
## [1] &quot;handle-8&quot;
## 
## [[1]]$value
##             A B
## 1  0.12490994 1
## 2 -0.08443145 2
## 3 -1.72988336 3
## 4  0.05831478 4
## 5  0.95520275 5
</code></pre>

<p>Sometimes you don&#39;t know the <code>key</code> or <code>handle</code>, but only the <code>value</code> of a node, and you want to do a <code>decrease-key</code> operation.
Suppose you want to decrease the key of a node with value <code>V-1</code>, then you would to need to call <code>handle</code> with a value argument and a missing <code>key</code>:</p>

<pre><code class="r">  hands &lt;- handle(fheap, value=&quot;V1&quot;)
  decrease_key(fheap, from=hands[[1]]$key, to=-1000, hands[[1]]$handle)
</code></pre>

<pre><code>## An object of class fibonacci_heap&lt;numeric, SEXP&gt;
## 
## Peek: -1000 -&gt; character, ...
</code></pre>

<pre><code class="r">  peek(fheap)
</code></pre>

<pre><code>## $`-1000`
## [1] &quot;V1&quot;
</code></pre>

<p><strong>NOTE</strong>: Getting the handles from a value is a costly operation, because we need to compare all entries of the heap with the supplied argument value.
If your supplied argument is, for instance, a large dataframe this will quickly become slow. So it is recommended to use this function cautiously.</p>

<p>The handle function for values can take multiple elements, too. However, here we need to supply a <code>list</code> and not a vector (for obvious reasons).</p>

<pre><code class="r">  hands &lt;- handle(fheap, value=list(&quot;V1&quot;, list(a=2)))
  hands
</code></pre>

<pre><code>## [[1]]
## [[1]]$handle
## [1] &quot;handle-5&quot;
## 
## [[1]]$key
## [1] -1000
## 
## 
## [[2]]
## [[2]]$handle
## [1] &quot;handle-9&quot;
## 
## [[2]]$key
## [1] -20
</code></pre>

<h3>Retrieving values from a heap</h3>

<p>Finally, you can get all data from a heap, by calling the <code>value</code> function:</p>

<pre><code class="r">  val &lt;- values(fheap)
  val[1:2]
</code></pre>

<pre><code>## $`-1000`
## $`-1000`$handle
## [1] &quot;handle-5&quot;
## 
## $`-1000`$key
## [1] -1000
## 
## $`-1000`$value
## [1] &quot;V1&quot;
## 
## 
## $`-20`
## $`-20`$handle
## [1] &quot;handle-9&quot;
## 
## $`-20`$key
## [1] -20
## 
## $`-20`$value
## $`-20`$value$a
## [1] 2
</code></pre>

<p>In all of these scenarios neither the key nor the value need to be unique, because the handle (node id) always is.</p>

<h3>Clearing the heap</h3>

<p>You can remove all entries from a heap by calling:</p>

<pre><code class="r">  fheap &lt;- clear(fheap)
  fheap
</code></pre>

<pre><code>## An object of class fibonacci_heap&lt;numeric, SEXP&gt;
## 
## Peek: NULL -&gt; NULL, ...
</code></pre>

<h3>Use case</h3>

<p>As a last example, consider this use case whre we use a <code>character</code> heap.</p>

<pre><code class="r">  library(&#39;purrr&#39;)
  bheap &lt;- binomial_heap(&quot;character&quot;)
  bheap &lt;- insert(bheap, letters[c(2:6, 5, 5)], c(2:6, 5L, 7L))
  bheap &lt;- insert(bheap, &quot;x&quot;, data.frame(A=&quot;hi&quot;))
  bheap &lt;- insert(bheap, &quot;x&quot;, list(a=2))
  peek(bheap)
</code></pre>

<pre><code>## $b
## [1] 2
</code></pre>

<pre><code class="r">  vector.keys &lt;- handle(bheap, &quot;x&quot;) %&gt;%
    purrr::map_chr(.f = function(x) x$handle)
  vector.keys
</code></pre>

<pre><code>## [1] &quot;handle-7&quot; &quot;handle-8&quot;
</code></pre>

<pre><code class="r">  decrease_key(bheap, from=&quot;x&quot;, to=&quot;b&quot;, handle=vector.keys[1])
</code></pre>

<pre><code>## An object of class binomial_heap&lt;character, SEXP&gt;
## 
## Peek: b -&gt; data.frame, ...
</code></pre>

<pre><code class="r">  peek(bheap)
</code></pre>

<pre><code>## $b
##    A
## 1 hi
</code></pre>

<pre><code class="r">  hand &lt;- handle(bheap, key = &quot;b&quot;)
  hand
</code></pre>

<pre><code>## [[1]]
## [[1]]$handle
## [1] &quot;handle-0&quot;
## 
## [[1]]$value
## [1] 2
## 
## 
## [[2]]
## [[2]]$handle
## [1] &quot;handle-7&quot;
## 
## [[2]]$value
##    A
## 1 hi
</code></pre>

<pre><code class="r">  decrease_key(bheap, from=&quot;b&quot;, to=&quot;a&quot;, handle=hand[[2]]$handle)
</code></pre>

<pre><code>## An object of class binomial_heap&lt;character, SEXP&gt;
## 
## Peek: a -&gt; data.frame, ...
</code></pre>

<pre><code class="r">  pop(bheap)
</code></pre>

<pre><code>## $a
##    A
## 1 hi
</code></pre>

<pre><code class="r">  pop(bheap)
</code></pre>

<pre><code>## $b
## [1] 2
</code></pre>

<h2>Hashmaps, bimaps and multimaps</h2>

<p>Maps use hash functions to store key-value pairs. Given a key, the hash function computes a <em>bucket</em> where the value is stored, making lookup, insertion and deletion on average possible in \(\mathcal{O}(1)\) time. In the worst case these runtimes decrease to \(\mathcal{O}(n)\) time, where \(n\) is the number of entries in a bucket. The difference between the three classes is that hashmaps and multimaps compute a mapping from keys to values (the hash function)
\[ \, f: \mathcal{K} \rightarrow \mathcal{V} \, \]
in <strong>&#39;one direction&#39;</strong>, while bimaps also compute a mapping
\[ \, f: \mathcal{V} \rightarrow \mathcal{K} \, \]
in the <strong>&#39;other direction&#39;</strong>. So a bimap is essentially a combination of two hashmaps. The difference between a hashmap and a multimap is that for hashs only <em>one</em> unique key can be stored for a value, while multimaps allow storing the same key several times fur multiple values,</p>

<p>Hashmaps and multimaps define mappings in a single direction, for that reason we can use arbitrary R objects as values.
For bimaps we can only use primitive types, otherwise it will be difficult to access certain key-value pairs.</p>

<p>Let&#39;s quickly have a look at some examples. We define <code>character</code> hashmap and mulimaps and <code>character/integer</code> bimap.</p>

<pre><code class="r">  hash  &lt;- hashmap(&quot;character&quot;)
  mm    &lt;- multimap(&quot;character&quot;)
  bimap &lt;- bimap(&quot;character&quot;, &quot;integer&quot;)
</code></pre>

<p>Insertion to maps works just like before, by calling the <code>insert</code> function or using a subset operator.
As explained for hashmap and multimap we can use all kinds of <code>values</code>, for bimaps we need to define the a primitive type as well.</p>

<pre><code class="r">  keys   &lt;- paste0(&quot;V&quot;, 1:5)
  values &lt;- 1:5

  hash   &lt;- insert(hash, keys[1:4], values[1:4])
  mm     &lt;- insert(mm, keys[c(2, 2)], list(list(a=1), data.frame(a=rnorm(5), 2, 3)))
  bimap  &lt;- insert(bimap, keys[1:4], values[1:4])

  hash[keys[5]]  &lt;- values[5]
  bimap[keys[5]] &lt;- values[5]
  mm[keys[5]]    &lt;- diag(5)
</code></pre>

<p>Values (and keys in the case of bimaps) can then be accessed like this:</p>

<pre><code class="r">  at(hash, keys[1])
</code></pre>

<pre><code>## [[1]]
## [1] 1
</code></pre>

<pre><code class="r">  hash[keys[1]]
</code></pre>

<pre><code>## [[1]]
## [1] 1
</code></pre>

<pre><code class="r">  at(bimap, keys[1], &quot;values&quot;)
</code></pre>

<pre><code>## [1] 1
</code></pre>

<pre><code class="r">  at(bimap, values[2], &quot;keys&quot;)
</code></pre>

<pre><code>## [1] &quot;V2&quot;
</code></pre>

<pre><code class="r">  at(bimap, keys[1])
</code></pre>

<pre><code>## [1] 1
</code></pre>

<pre><code class="r">  at(mm, keys[2])
</code></pre>

<pre><code>## [[1]]
##            a X2 X3
## 1 -0.3330289  2  3
## 2  0.5126821  2  3
## 3 -1.0957836  2  3
## 4 -1.5069147  2  3
## 5 -0.3937187  2  3
## 
## [[2]]
## [[2]]$a
## [1] 1
</code></pre>

<pre><code class="r">  mm[keys[5]]
</code></pre>

<pre><code>## [[1]]
##  [1] 1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1
</code></pre>

<p>For hashmaps and multimaps the subset-operator <code>[</code> is also supported for accessing elements. 
This does not make so much sense for bimaps, because here we have to choose whether we want to access keys or values. 
In the example on the top we showed how both is possible by either providing <code>keys</code> or <code>values</code> as third argument to the <code>get</code> function. 
If you leave it out, then the third argument defaults to <code>values</code>.</p>

<p>If you want to directly access <code>keys</code> or <code>values</code> as vectors or have a look at a few random elements, you would call:</p>

<pre><code class="r">  keys(bimap)
</code></pre>

<pre><code>## [1] &quot;V1&quot; &quot;V2&quot; &quot;V3&quot; &quot;V4&quot; &quot;V5&quot;
</code></pre>

<pre><code class="r">  values(hash)
</code></pre>

<pre><code>## [[1]]
## [1] 5
## 
## [[2]]
## [1] 3
## 
## [[3]]
## [1] 2
## 
## [[4]]
## [1] 4
## 
## [[5]]
## [1] 1
</code></pre>

<pre><code class="r">  peek(bimap)
</code></pre>

<pre><code>## $V1
## [1] 1
## 
## $V2
## [1] 2
## 
## $V3
## [1] 3
## 
## $V4
## [1] 4
## 
## $V5
## [1] 5
</code></pre>

<p>Removing entries in all of the three map classes works like this:</p>

<pre><code class="r">  hash &lt;- erase(hash, keys[1])
  hash
</code></pre>

<pre><code>## An object of class hashmap&lt;character,T&gt;
## 
## V2 -&gt; integer
## V3 -&gt; integer
## V4 -&gt; integer
## V5 -&gt; integer
</code></pre>

<pre><code class="r">  mm &lt;- erase(mm, keys[2])
</code></pre>

<pre><code>## Note: method with signature &#39;map#vector#missing&#39; chosen for function &#39;erase&#39;,
##  target signature &#39;multimap#character#missing&#39;.
##  &quot;multimap#vector#ANY&quot; would also be valid
</code></pre>

<pre><code class="r">  mm
</code></pre>

<pre><code>## An object of class multimap&lt;character,T&gt;
## 
## V5 -&gt; numeric
</code></pre>

<p>As you can see for multimaps, all key-value pairs get removed, when the function is called as above. 
If you are interested in only one specific  key-value pair, you additionally need to supply the respective value:</p>

<pre><code class="r">  mm &lt;- insert(mm, keys[c(2, 2)], list(list(a=1), data.frame(a=rnorm(5), 2, 3)))
  mm &lt;- erase(mm, keys[2], list(a=1))
  mm[ keys[2] ]
</code></pre>

<pre><code>## [[1]]
##             a X2 X3
## 1  2.88401078  2  3
## 2 -0.03468948  2  3
## 3  1.22220184  2  3
## 4 -0.62516613  2  3
## 5  0.57300251  2  3
</code></pre>

<p>For bimaps we can also remove from the other side, i.e. when we provide a value:</p>

<pre><code class="r">  bimap &lt;- erase(bimap, value=values[1])
  bimap
</code></pre>

<pre><code>## An object of class bimap&lt;character,T&gt;
## 
## V2 &lt;--&gt; integer
## V3 &lt;--&gt; integer
## V4 &lt;--&gt; integer
## V5 &lt;--&gt; integer
</code></pre>

<p>For multimaps, where we allow having the same key several times, removing an entry as above removes <em>all</em> the key-value pairs with the</p>

<p>The three different map types support to easily clear the entire data structure using:</p>

<pre><code class="r">  clear(bimap)
</code></pre>

<pre><code>## An object of class bimap&lt;character,T&gt;
## 
## NULL &lt;--&gt; NULL
</code></pre>

<pre><code class="r">  size(bimap)
</code></pre>

<pre><code>## [1] 0
</code></pre>

<pre><code class="r">  clear(hash)
</code></pre>

<pre><code>## An object of class hashmap&lt;character,T&gt;
## 
## NULL -&gt; NULL
</code></pre>

<pre><code class="r">  size(hash)
</code></pre>

<pre><code>## [1] 0
</code></pre>

<pre><code class="r">  clear(mm)
</code></pre>

<pre><code>## An object of class multimap&lt;character,T&gt;
## 
## NULL -&gt; NULL
</code></pre>

<pre><code class="r">  size(mm)
</code></pre>

<pre><code>## [1] 0
</code></pre>

<h2>Queues and stacks</h2>

<p>Queues and stackes are two list datastructures using the <code>STL</code>&#39;s <code>std::deque</code> 
in the backend, i.e. insertion at the end and getting the first element can be done
in constant time \(\mathcal{O}(1)\) . Queues and stacks are for example used in
<em>depths-first-search</em> and <em>breadth-first-search</em> making them versatile datastructures.
While queues use the <em>first-in-first-out</em> principle, stacks use the <em>last-in-first-out</em> principle.</p>

<p>The two datatypes use the exact same methods. You can instantiate a stack or a queue using:</p>

<pre><code class="r">  qu &lt;- queue()
  st &lt;- stack()
</code></pre>

<p>As we heaps and hashmap/multimaps you acn pack anything you want into the containers.
Now, let&#39;s again insert some data. Single values can just be supplied as argument, while 
multiple values need to be packed into a list again.</p>

<pre><code class="r">  qu &lt;- insert(qu, 1)
  qu &lt;- insert(qu, list(rnorm(5), 1, diag(3)))
  st &lt;- insert(st, as.list(rnorm(5)))
  st &lt;- insert(st, data.frame(a=1:3, b=3:1))
</code></pre>

<p><strong>BEWARE:</strong> If you add <em>one</em> <code>vector</code> to queues and stacks it will add <em>one</em> element:</p>

<pre><code class="r">  peek(qu)
</code></pre>

<pre><code>## [1] 1
</code></pre>

<pre><code class="r">  peek(st)
</code></pre>

<pre><code>##   a b
## 1 1 3
## 2 2 2
## 3 3 1
</code></pre>

<p>If you want to remove elements, call the <code>pop</code> function which will remove the head of the data structure.</p>

<pre><code class="r">  pop(st)
</code></pre>

<pre><code>##   a b
## 1 1 3
## 2 2 2
## 3 3 1
</code></pre>

<pre><code class="r">  pop(st)
</code></pre>

<pre><code>## [1] 1.276806
</code></pre>

<p>For a <code>queue</code> <code>pop</code> and <code>peek</code> return the <em>first</em> element that got inserted, while a stack returns the <em>last</em> element that was inserted.</p>

<p>The size of a deque can be computed by calling:</p>

<pre><code class="r">  size(qu)
</code></pre>

<pre><code>## [1] 4
</code></pre>

<p>Stacks and queues can be emptied like this:</p>

<pre><code class="r">  qu &lt;- clear(qu)
  qu
</code></pre>

<pre><code>## An object of class queue&lt;SEXP&gt;
## 
## Peek: NULL, ...
</code></pre>

<h2>Session info</h2>

<pre><code class="r">  sessionInfo()
</code></pre>

<pre><code>## R version 4.0.2 (2020-06-22)
## Platform: x86_64-pc-linux-gnu (64-bit)
## Running under: Ubuntu 20.04.1 LTS
## 
## Matrix products: default
## BLAS/LAPACK: /usr/lib/x86_64-linux-gnu/openblas-openmp/libopenblasp-r0.3.8.so
## 
## locale:
##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    
##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   
##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 
##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            
## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
## [1] purrr_0.3.4          datastructures_0.2.9 Rcpp_1.0.5          
## 
## loaded via a namespace (and not attached):
##  [1] compiler_4.0.2   magrittr_1.5     tools_4.0.2      codetools_0.2-16
##  [5] stringi_1.4.6    knitr_1.29       stringr_1.4.0    xfun_0.16       
##  [9] rlang_0.4.7      evaluate_0.14
</code></pre>

</body>

</html>
